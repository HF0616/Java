# 继承

## 类，超类和子类

### 定义子类

```java
public class Manager extends Employee
{
		add methods and fileds
}
```

通过扩展超类定义子类的时候，只需要指出子类与超类的不同之处。因此设计类的时候，应该将最一般的方法放在超类中，而将特殊的方法放在子类中。

### 覆盖方法

- 继承的类不能访问超类的私有字段，需要使用公共接口来访问。
- 访问超类的公共接口方法要使用到$super$

$super$与$this$不同，$super$不是一个对象的引用，它只是指示编译器调用超类的方法的特殊关键字。

### 子类构造器

```java
public Manager(String name,double salary,int month,int day)
{
		super(name,salary,year,day);
		bonus=0;
}
```

子类不能访问超类私有字段，所以必须通过一个构造器来初始化这些私有字段。可以利用特殊的super语法调用这个构造器。

如果子类的构造器没有显式地调用超类的构造器，将自动调用超类的无参数构造器。如果超类没有无参数构造器，并且子类的构造器中又没有显式地调用超类的其他构造器，将会报错。

### 继承层次

一个公共超类派生出来的所有类的集合称为继承层次。通常，一个祖先类可以有多个子孙链。

### 多态

对象变量是多态的，一个$Employee$类型的变量即可以引用一个$Employee$类型的变量，也可以引用任何一个子类的对象。

子类引用数组就可以转换成超类引用数组，而不需要使用强制类型转换。

注意：子类方法不能低于超类方法的可见性。

### 组织继承：final类和方法

不允许扩展的类被称为$final$类。定义的时候这各类用$final$修饰。类中的某个特定的方法也可以被声明为$final$，如果这样做，子类就不能覆盖这个方法。

- $instanceof$判断是否可以强制类型转换

```java
if (staff[1] instanceof Manager)
{
		boss=(Manager) stsff[1];
}
```

### 抽象类

- 包含一个或多个抽象方法的类本身就可以必须声明为抽象的。
- 抽象类可以包含字段的具体方法。
- 扩展抽象类可以实现父类全部的抽象方法，也可以实现部分抽象方法，这样的话子类也还是抽象的。

### 受保护的访问

如果将超类中的字段声明为$proteced$而不是$privae$，那么子类方法就可以直接访问这个字段。保护字段只能由同一个包中的类使用。

- $private$—仅对本包可见。
- $public$—对外部完全可见。
- $protected$—对本包的所有子类可见。
- 默认—对本包可见。

## $Object:所有类的超类$

如果没有明确指定超类，$Object$就被认为是这个超类。

### $Object$类型的变量

可以使用$Object$类型的变量引用任何类型的对象。$Object$类型的变量只能用于作为各种值的一个泛型容器。要想对其中的内容进行操作，还需要清除地知道数据的原始类型。

在$Java$中，只有基本类型不是对象。

### $equals方法$

$object$的$equals$方法用于检测一个对象是否等于另一个对象。

### 相等测试与继承

### $hashcode$方法

### $tostring$方法

## 泛型数组列表

$ArrayList$是一个有类型参数的泛型类。为了指定数组列表保存的元素对象的类型，需要用一对尖括号来追加到$ArrayList$后面。

### 声明数组列表

```java
ArrayList<Employee> staff = new ArrayList<Employee>();

//或者

var staff = new ArrayList<Employee>();
```

- 使用$add$方法可以将元素添加到数组列表中。
- 如果调用$add$而内部数组已经满了，数组列表就会自动的创建一个更大的数组。并将所有的对象从较小的数组拷贝了较大的数组中。
- $ensureCapacity()$方法可以在填充数组之前分配空间。
- 可以把容量传递给$ArrayList$构造器。

```java
ArrayList<Employee> staff = new ArrayList<>(100)
```

## 对象包装与自动装箱

- 自动装箱：
    
    向$ArrayList<Integer>$添加$int$类型的元素。调用$list.add(3)$将自动地转换为$list.add(Integer.valueOf(3))$这种变换称为自动装箱。
    
- 自动拆箱
    
    $int\ n=list.get(i);$转换成$int\ n=list.get(i).intValue()$叫做自动拆箱。
    

大多数情况容易有一种假象，认为基本类型与它们的对象包装器是一样的。但它们有一个很大的不同：同一性。

```java
Integer a=1000;
Integet b=1000;
//为False
if(a==b)...
```

## 参数数量可变的方法

$printf$方法就是一个参数可变的方法，它是这样定义的：

```java
public class PrintStream
{
		public PrintStream printf(String fmt,Object...args){
				return format(fmt,args)
		}
}
```

## 枚举类

定义枚举类：

```java
public enum Size{SMALL,MEDIUM,LARGE,EXTRA_LARGE}
```

为u枚举类型增加构造i：

```java
public enum Size
{
		SMALL("s"),MEDIUM("M"),LARGE("L"),EXTRA_LARGE("XL");

		private String abbreviation;
		
		private Size(String abbreviation){this.abbreviation=abbreviation;}
		public String getAbbreviation(){return abbreviation;}
}
```

- 枚举的构造器总是私有的。
- 所有的枚举类型都是$Eum$的子类。
    - 继承了许多方法
- 枚举类型都有一个静态values方法，它将返回一个包含全部枚举值的数组。