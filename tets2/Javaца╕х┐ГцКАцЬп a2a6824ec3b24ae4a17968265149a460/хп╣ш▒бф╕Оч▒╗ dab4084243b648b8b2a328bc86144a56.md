# 对象与类

## 面向对象编程概述

- $OOP$：面向对象程序设计。

面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。只要对象能满足要求。就不关心其功能到底是如何实现的。

### 类

类是构造对象的模板或蓝图。

- 创建类的实例：由类构造对象的过程。
- 封装（有时称为数据隐藏）：将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现方式。
    - 实例字段：对象中的数据。
        
        作为一个类实例，特定对象都有一组特定的实例字段值。这个值的集合就是这个对象当前的状态。
        
    - 方法：操作数据的过程。
    
    实现封装的关键在于，决不能让类中的方法直接访问其它类的实例字段。程序只能通过对象的方法与对象数据进行交互。
    
- 继承：通过扩展一个类来建立另外一个类的过程叫做继承。

### 对象

要使用$OOP$，一定要清除对象的三个主要特性。

- 对象的行为——可以对对象完成哪些操作，或者可以对对象应用哪些方法？
- 对象的状态——当调用那些方法时，对象如何响应？
- 对象的标识——如何区分具有相同行为与状态的不同对象？

对象的这些特性之间会相互影响。

### 识别类

面向对象编程：首先从识别类开始，然后再为各个类添加方法。

### 类与类之间的关系

- 依赖（$uses-a$）
    
    如果一个类的方法使用或操纵另一个类的对象，我们就说一个类依赖于另一个类。应该尽可能将类之间的相互依赖降低。（减少类之间的耦合。）
    
- 聚合（$has-a$）
    
    包含关系，意味着A类的对象包含B类的对象。
    
- 继承（$is-a$）
    
    如果类A扩展类B，类A不但包含从类B继承的方法，还会有一些额外地功能。
    

## 使用预定以类

对于$Math$类，由于没有数据，因此不必考虑创建对象和初始化它们的实例字段，因为根本没有实例字段。

### 对象与对象变量

- 构造器：一种构造并初始化对象的一种特是方法。
    - 构造器的名字应该与类名相同。
    - new构造对象。
    - 任何对象变量的值都是对存储在另外一个地方的某个对象的引用。
- Data类和$LocalData$类
    - Data类的实例有一个状态，即特定的时间点。
    - $LocalData$类不要使用构造器来构造对象，而是使用静态工厂方法。

### 更改器方法和访问器方法

- 更改器方法：调用方法后会改变对象的状态。
- 访问器方法：只访问对象而不修改对象的方法。

## 用户自定义类

- public类：在一个源文件中只有一个公共类，但可以有任意数目的非公共类。
    - 这个类中包含了$mian$方法。
    - 编译源码后将在该目录下创建所有类的$.class$文件。
    - 用包含$mian$方法的类名启动程序。

### 剖析类

被标记为$public$的方法：意味着任何类的任何方法都可以调用这些方法。

关键字$private$标记的实例字段：确保只有该类自身的方法可以访问这个字段。

### 从构造器开始

- 构造器与类同名。在构造类对象时，构造器会运行，从而将实例字段初始化为所希望的初始状态。
- 构造器总是结合$new$运算符来调用。

注意：不要在构造器中定义与实例字段同名的局部变量。这些变量会遮蔽实例字段。

### 用$var$声明变量

- $var$关键字只能用于方法中的局部变量。参数和字段的类型必须声明。

### 使用$null$引用

如果对$null$使用一个方法会引发异常。，我们有“宽容型”和“严格型”两种解决方法：

- 宽容型：如果出现$null$，就把$null$参数转换为一个适当的非$null$值。
- 严格型：干脆拒绝$null$参数
    
    ```java
    //这是一个构造器
    public Employee(String n,double s,int year, int month,int day)
    {
    		Objects.requireNonNull(n,"The name can not be null");
    		name=n;
    }
    ```
    

### 隐式参数与显式参数

- 隐式参数：方法名之前的类名类型的对象。
    - 在每一个方法中，关键字$this$指示隐式参数。
- 显式参数：方法后面括号中的参数。

### 封装的优点

要想获得和设置实例字段的值，你需要提供下面三项内容：

- 一个私有的数据字段。
- 一个公共的字段访问器方法。
- 一个公共的字段更改器方法。

注意不要编写返回可变对象引用的访问器方法。这里有一个经验，如果需要返回一个可变数据字段的副本，就应该使用clone。

```java
class Employee
{
		...
		public Data getGireDay()
		{
				return (Data) hireDay.clone();
		}
}
```

### 基于类的访问权限

一个方法可以访问所属类的所有对象的私有数据。

```java
class Employee
{
		...
		public boolean equals(Employee other)
		{
				return name.equals(other.name);
		}
}

//使用
if(harry.equals(boss))
```

boss是Employee类型的对象，而Employee类的方法可以访问任何Employee类型对象的私有字段。

### 私有方法

所有的数据字段都设置为私有的，那么方法呢？

- 大多数的方法是公共的。
- 私有的情况。
    - 希望将一个计算代码分解成若干个独立的辅助方法。
    - 需要一个特殊的协议或调用次序。

### $final$实例字段

定义为$final$的实例字段必须在构造对象时初始化，也就是说，必须确保每一个构造器执行之后，这个字段的值已经设置，并且以后不能再修改这个值。

- $final$关键字只是表示对象变量中对象引用不会再指示另一个不同的对象。不过这个对象可以更改。

## 静态对象与静态方法

main方法都被$static$修饰

### 静态字段

- 如果将一个字段定义为$static$，每个类只有一个这样的字段。而对于非静态的实例字段，每个对象都有自己的一个副本。
- 静态字段属于类而不属于对象。

### 静态常量

$Math$类中的$PI$就是一个静态常量，我们可以用$Math.PI$访问它。

### 静态方法

静态方法是不在对象上使用的方法。例如$Math$类的$pow$方法就是一个静态方法。

- 静态方法不能访问实例字段。
- 静态方法可以访问静态字段。
- 可以使用对象调用静态方法访问静态字段。（不建议这样做。）

### 工厂方法

静态方法的另一种常见的用途是使用静态工厂方法来构造对象。

```java
NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance();
```

## 方法参数

- 按值调用：方法接收的是调用者提供的值。
- 按引用调用：方法接收的是调用者提供的地址。

Java程序总是按值调用，也就是说，方法得到的是所有参数值的一个副本。具体来讲，方法不能修改传递给他的任何参数的内容。

当传递一个对象时，对象中的字段的值可以被修改，但是该对象本身不能被修改。

## 对象构造

### 重载

- 如果多个构造方法有相同的名字不同的参数，就出现了重载。
- 编译器根据匹配参数找到最好的构造方法叫做重载解析。

Java允许重载任何方法，而不只是构造方法。

### 默认字段初始化

如果构造其中没有显式地为字段设置初始值，那么会被自动地设为默认值。这不是一个好主意。

### 无参数构造器

- 如果编写一个类没有写构造器时，就会默认提供一个无参数构造器。字段值设置为默认。
- 如果提供了一个有参数构造器，但是没有无参数构造器，那么使用无参数构造器就是不合法的。

### 显式字段初始化

- 在执行构造器之前完成初始化操作。
- 初始化数据不一定是常量
    
    ```java
    class Employee
    {
    		private static int nextId;
    		private int id=assignId();
    		...
    		private static int assignId()
    		{
    				int r=nextId;
    				nextId++;
    				return r;
    		}
    }
    ```
    

### 调用另一个构造器

关键字$this$指示一个方法的隐式参数。不过这个关键字还有另一个含义。

如果构造器的第一个语句形如this(…)，这个构造器将调用同一个类的另一个构造器。

### 初始化块

两种初始化数据字段的方法：

- 在构造器中设置值。
- 在声明中赋值。

### 对象析构与$finalize$方法

$Java$不支持析构器：$Java$会自动垃圾回收，不需要人工回收内存。

## 包

$Java$允许使用包将类组织在一个集合中。借助包可以方便地组织自己的代码。

### 包名

为了保证包名的绝对唯一性，要用一个因特网域名以逆序的形式作为包名。从编译器的角度来看，嵌套的包之间没有任何的关系。例如$java.util$包与$java.util.jar$包毫无关系。每一个包都是独立的集合。

### 类的的导入

一个类可以使用所属包的所有类，以及其他包的公共类（$public\ class$）。

我们可以使用两种方式访问访问另一个包中的公共类：

- 使用完全限定名：包后面跟类名。
- 使用$import$语句。

### 静态导入

### 在包中增加类

### 包的访问

- 标记$public$的部分可以由任意类使用。
- 标记$private$的部分只能由定义它们的类使用。
- 没有标记$private$或$public$的部分（类，方法或变量）可以由同一包中的所有方法访问。

### 类路径

### 设置类路径

## $JAR$文件

在将程序打包时，你一定希望只向用户提供一个单独的文件，而不是一个包含大量类文件的目录结构。$Java$归档（$JAR$）文是为次目的而设计的。

### 创建$JAR$文件

语法：

```java
jar cvf jarFileName file1 file2...
```

### 多版本$JAR$文件

### 关于命令行选项说明

## 文档注释

## 类的设计技巧